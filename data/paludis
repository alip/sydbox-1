/* Sydbox configuration file for use with Paludis package mangler */

{
    "core" : {
        "sandbox" : { "exec"    : "off", /* execve(2) sandboxing */
                      "read"    : "off", /* read sandboxing */
                      "write"   : "deny", /* write sandboxing */
                      "network" : "deny" /* network sandboxing */
        },
        "whitelist" : { "per_process_directories"     : true, /* Allow per process directories like /proc/$pid */
                        "successful_bind"             : true, /* Add successful bind() address to connect() whitelist */
                        "unsupported_socket_families" : true /* Allow unsupported socket families like AF_NETLINK */
        },
        "abort" : { "decision"  : "contall" /* Kill/Resume all children on fatal errors? (one of contall,killall) */
        },
        "panic" : { "decision"  : "kill", /* What to do on panic? (one of cont,kill,contall,killall) */
                    "exit_code" : -1 /* If decision is contall or killall, specifies the exit code. */
        },
        "violation" : { "decision"    : "deny", /* What to do on access violations? (one of deny,cont,kill,contall,killall) */
                        "exit_code"   : -1, /* If decision is contall or killall, specifies the exit code. */
                        "raise_fail" : false, /* Raise access violations for simple failures like path resolution errors? */
                        "raise_safe" : false /* Raise access violations for "safe" violations like -EEXIST for mkdir() */
        },
        "trace" : { "follow_fork"   : true, /* Follow forks? */
                    "exit_wait_all" : true, /* Wait all children to exit before exiting? */
                    "magic_lock"    : "off", /* Initial state of the magic lock */
                    "interrupt"     : "while_wait", /* Interrupt handling */
                    "use_seccomp"   : true /* Use seccomp user filter  */
        },
        "match" : { "case_sensitive" : true, /* Case sensitive matching */
                    "no_wildcard"    : "prefix" /* Append '/***' to the end of patterns with no '*' or '?' in them */
        }
    },

    "log" : { "console_fd" : 2, /* Messages with level higher than message go to standard error as well. */
              "file"       : "", /* Specify a path or leave it empty for no file logging. */
              "level"      : 2, /* 0:fatal 1:warning 2:message 3:info 4:debug 5:trace */
              "timestamp"  : true /* Prefix log messages with timestamp */
            },

    "exec" : { "resume_if_match" : [ ],
               "kill_if_match"   : [ ]
             },

    "filter" :
        { "exec"    : [ ],
          "read"    : [ ],
          "write"   : [ ],
          "network" : [ ]
        },

    "whitelist" :
        { "exec" : [ ],
          "read" : [ ],
          "write" : [ "/dev/stdout",
                      "/dev/stderr",
                      "/dev/zero",
                      "/dev/null",
                      "/dev/full",
                      "/dev/console",
                      "/dev/random",
                      "/dev/ptmx",
                      "/dev/fd/***",
                      "/dev/tty*",
                      "/dev/pty*",
                      "/dev/tts*",
                      "/dev/pts*",
                      "/proc/self/fd/***",
                      "/dev/shm/***",
                      "/selinux/context/***",
                      "/proc/self/attr/***",
                      "/proc/self/task/***",
                      "/tmp/***",
                      "/var/tmp/***",
                      "/var/cache/***"
                    ],
          "network" :
            { "bind" : [ "LOOPBACK@0",
                         "LOOPBACK@1024-65535",
                         "LOOPBACK6@0",
                         "LOOPBACK6@1024-65535"
                       ],
              "connect" : [ "unix:/var/run/nscd/socket",
                            "unix:/run/nscd/socket"
                          ]
            }
        },
    "blacklist" :
        { "exec"    : [ ],
          "read"    : [ ],
          "write"   : [ ],
          "network" : { "bind"    : [ ],
                        "connect" : [ ]
                      }
        }
}

/* vim: set et sw=4 sts=4 ft=javascript : */
